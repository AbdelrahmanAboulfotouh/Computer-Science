Dive Into Systems <color="green">
Dive Into Systems

0. Introduction<br/>
1. By the C, the Beautiful C<br/>
  1.1. Getting Started Programming in C<br/>
  1.2. Input/Output (printf and scanf)<br/>
  1.3. Conditionals and Loops<br/>
  1.4. Functions<br/>
  1.5. Arrays and Strings<br/>
  1.6. Structs<br/>
  1.7. Summary<br/>
  1.8. Exercises<br/>
2. A Deeper Dive Into C
  2.1. Parts of Program Memory and Scope
  2.2. C Pointer Variables
  2.3. Pointers and Functions
  2.4. Dynamic Memory Allocation
  2.5. Arrays in C
  2.6. Strings and the String Library
  2.7. Structs
  2.8. Input / Output in C
  2.9. Advanced C Features
    2.9.1. Constants, switch, enum, and typedef
    2.9.2. Command Line Arguments
    2.9.3. The void* Type
    2.9.4. Pointer Arithmetic
    2.9.5. C Libraries: Using, Compiling and Linking
    2.9.6. Writing and using your own C libraries (and compiling multiple .c and .h files)
    2.9.7. Compiling C to Assembly and Compiling Assembly Code
  2.10. Summary
  2.11. Exercises
3. C Debugging Tools
  3.1. Debugging with GDB
  3.2. GDB Commands in Detail
  3.3. Debugging Memory with Valgrind
  3.4. Advanced GDB Features
  3.5. Debugging Assembly Code
  3.6. Debugging Multi-threaded Programs
  3.7. Summary
4. Binary and Data Representation
  4.1. Number Bases and Unsigned Integers
  4.2. Converting Between Bases
  4.3. Signed Binary Integers
  4.4. Binary Integer Arithmetic
  4.5. Overflow
  4.6. Bitwise Operators
  4.7. Integer Byte Order
  4.8. Real Numbers in Binary
  4.9. Summary
  4.10. Exercises
5. What von Neumann Knew: Computer Architecture
  5.1. The Origins of Modern Computing
  5.2. The von Neumann Architecture
  5.3. Logic Gates
  5.4. Circuits
  5.4.1. Arithmetic and Logic Circuits
  5.4.2. Control Circuits
  5.4.3. Storage Circuits
  5.5. Building a Processor
  5.6. The Processorâ€™s Execution of Program Instructions
  5.7. Pipelining Instruction Execution
  5.8. Advanced Pipelining Considerations
  5.9. Looking Ahead: CPUs Today
  5.10. Summary
  5.11. Exercises
6. Under the C: Dive into Assembly
  7. 64-bit x86 Assembly
  7.1. Assembly Basics
  7.2. Common Instructions
  7.3. Additional Arithmetic Instructions
  7.4. Conditional Control and Loops
  7.4.1. Preliminaries
  7.4.2. If Statements
  7.4.3. Loops
  7.5. Functions in Assembly
  7.6. Recursion
  7.7. Arrays in Assembly
  7.8. Matrices in Assembly
  7.9. Structs in Assembly
  7.10. Buffer Overflows
8. 32-bit x86 Assembly
  8.1. Assembly Basics
  8.2. Common Instructions
  8.3. Additional Arithmetic Instructions
  8.4. Conditional Control and Loops
  8.4.1. Preliminaries
  8.4.2. If Statements
  8.4.3. Loops
  8.5. Functions in Assembly
  8.6. Recursion
  8.7. Arrays in Assembly
  8.8. Matrices in Assembly
  8.9. Structs in Assembly
  8.10. Buffer Overflows
9. ARMv8 Assembly
  9.1. Assembly Basics
  9.2. Common Instructions
  9.3. Arithmetic Instructions
  9.4. Conditional Control and Loops
    9.4.1. Preliminaries
    9.4.2. If Statements
    9.4.3. Loops
  9.5. Functions in Assembly
  9.6. Recursion
  9.7. Arrays in Assembly
  9.8. Matrices in Assembly
  9.9. Structs in Assembly
  9.10. Buffer Overflows
10. Key Assembly Takeaways
11. Storage and the Memory Hierarchy
  11.1. The Memory Hierarchy
  11.2. Storage Devices
  11.3. Locality
  11.4. Caching
  11.5. Cache Analysis and Cachegrind
  11.6. Looking Ahead: Caching on Multicore Processors
  11.7. Summary
  11.8. Exercises
12. Code Optimization
  12.1. First Steps
  12.2. Other Compiler Optimizations
  12.3. Memory Considerations
  12.4. Summary
13. The Operating System
  13.1. Booting and Running
  13.2. Processes
  13.3. Virtual Memory
  13.4. Interprocess Communication
    13.4.1. Signals
    13.4.2. Message Passing
    13.4.3. Shared Memory
  13.5. Summary and Other OS Functionality
  13.6. Exercises
14. Leveraging Shared Memory in the Multicore Era
  14.1. Programming Multicore Systems
  14.2. POSIX Threads
  14.3. Synchronizing Threads
    14.3.1. Mutual Exclusion
    14.3.2. Semaphores
    14.3.3. Other Synchronization Constructs
  14.4. Measuring Parallel Performance
    14.4.1. Parallel Performance Basics
    14.4.2. Advanced Topics
  14.5. Cache Coherence
  14.6. Thread Safety
  14.7. Implicit Threading with OpenMP
  14.8. Summary
  14.9. Exercises
15. Looking Ahead: Other Parallel Systems
  15.1. Hardware Acceleration and CUDA
  15.2. Distributed Memory Systems
  15.3. To Exascale and Beyond
16. Appendix 1: Chapter 1 for Java Programmers
17. Appendix 2: Using Unix
  17.1. Unix Command Line and the Unix File System
  17.2. Man and the Unix Manual
  17.3. Remote Access
  17.4. Unix Editors
  17.5. make and Makefiles
  17.6 Searching: grep and find
  17.7 File Permissions
  17.8 Archiving and Compressing Files
  17.9 Process Control
  17.10 Timing
  17.11 Command History
  17.12 I/0 Redirection
  17.13 Pipes
  17.14 Dot Files and .bashrc
  17.15 Shell Programming
  17.16 Getting System Information
